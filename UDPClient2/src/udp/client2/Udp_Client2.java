/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package udp.client2;

import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.ListModel;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import java.util.Scanner;
import javazoom.jl.player.advanced.AdvancedPlayer;

/**
 *
 * @author Administrator
 */
public class Udp_Client2 extends javax.swing.JFrame {

    //ghi lai loai button duoc chon
    private final int INSERT = 1;
    private final int DELETE = 2;
    //ghi lai port cua node
    private static int PORT = 4002;
    private static int ReceivePortAddress = 6000;
    private static int ReceivePortDownload = 6001;
    //ghi lai ten cua node    
    private static String nodeName = "Node2";
    //ghi lai duong dan tap tin va thu muc cua node
    private static String folderPathRoot = "../UDPClient2/";
    private static String folderPathShare = "../UDPClient2/Node2FileShare/";
    private static String folderPathDownload = "../UDPClient2/Node2Download/";
    private static String filePathShareHeThong = "../UDPClient2/node2_listfileshare.txt";
    private static String filePathNodeName = "../UDPClient2/node.txt";

    //ghi lai ten file nhac duoc chon
    private String SelectedName = "";
    //ghi lai lenh thuc thi
    private String lenh = "";

    public PlayMp3Thread play = null;
    //public SendAndReceiveThread send = null;

    //
    private static InetAddress IPAddress;
    public static DatagramSocket socket = null;
    public static DatagramSocket socketRecieve = null;
    boolean keepGoing = false;

    /**
     * Creates new form Udp_Client1
     */
    public DatagramSocket getSocket() {
        return this.socket;
    }

    public String getFolderPathRoot() {
        return this.folderPathRoot;
    }

    public int getPort() {
        return this.PORT;
    }

    public void setReceivePort(int port) {
        this.ReceivePortAddress = port;
    }

    public int getReceivePort() {
        return this.ReceivePortAddress;
    }

    public int getReceivePortDownload() {
        return this.ReceivePortDownload;
    }

    public String getNodeName() {
        return this.nodeName;
    }

    public String getfilePathShareHeThong() {
        return this.filePathShareHeThong;
    }

    public void setFolderPathShare(String folderLink) {
        this.folderPathShare = folderLink;
    }

    public String getFolderPathShare() {
        return this.folderPathShare;
    }

    public void setFolderPathDownload(String folderLink) {
        this.folderPathDownload = folderLink;
    }

    public String getFolderPathDownload() {
        return this.folderPathDownload;
    }

    public String getSelectedName() {
        return this.SelectedName;
    }

    public void setSelectedName(String name) {
        this.SelectedName = name;
    }

    public void setLenh(String l) {
        this.lenh = l;
    }

    public String getLenh() {
        return this.lenh;
    }

    //lenh khoi tao
    public Udp_Client2() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jPaneMain = new javax.swing.JPanel();
        jPanelTop = new javax.swing.JPanel();
        lbTitle = new javax.swing.JLabel();
        jPanelMid = new javax.swing.JPanel();
        lbAddressOnline = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jListAddress = new javax.swing.JList<>();
        lbFileName = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jListFileName = new javax.swing.JList<>();
        btnUpdate = new javax.swing.JButton();
        btnInsert = new javax.swing.JButton();
        btnDelete = new javax.swing.JButton();
        jPanelBottom = new javax.swing.JPanel();
        lbFileHeThong = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jListFileShareTrenHeThong = new javax.swing.JList<>();
        lbFileDaTai = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        jListFileDaTai = new javax.swing.JList<>();
        btnDownload = new javax.swing.JButton();
        btnPlay = new javax.swing.JButton();
        tfSearch = new javax.swing.JTextField();
        btnSearch = new javax.swing.JButton();
        btnStop = new javax.swing.JButton();
        lbNameSearch = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        lbTitle.setFont(new java.awt.Font("VNI-Ariston", 3, 36)); // NOI18N
        lbTitle.setForeground(new java.awt.Color(255, 0, 51));
        lbTitle.setText("Peer To Peer");

        javax.swing.GroupLayout jPanelTopLayout = new javax.swing.GroupLayout(jPanelTop);
        jPanelTop.setLayout(jPanelTopLayout);
        jPanelTopLayout.setHorizontalGroup(
                jPanelTopLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelTopLayout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(lbTitle)
                        .addGap(222, 222, 222))
        );
        jPanelTopLayout.setVerticalGroup(
                jPanelTopLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanelTopLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(lbTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 45, Short.MAX_VALUE)
                        .addContainerGap())
        );

        lbAddressOnline.setFont(new java.awt.Font("Times New Roman", 3, 14)); // NOI18N
        lbAddressOnline.setForeground(new java.awt.Color(0, 102, 102));
        lbAddressOnline.setText("IP Address Online");

        jListAddress.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        jScrollPane1.setViewportView(jListAddress);

        lbFileName.setFont(new java.awt.Font("Times New Roman", 3, 14)); // NOI18N
        lbFileName.setForeground(new java.awt.Color(0, 102, 102));
        lbFileName.setText("Danh Sách File Đang Chia Sẻ");

        jListFileName.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        jScrollPane2.setViewportView(jListFileName);

        btnUpdate.setFont(new java.awt.Font("Times New Roman", 1, 12)); // NOI18N
        btnUpdate.setText("Update");
        btnUpdate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUpdateActionPerformed(evt);
            }
        });

        btnInsert.setFont(new java.awt.Font("Times New Roman", 1, 12)); // NOI18N
        btnInsert.setText("Insert");
        btnInsert.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnInsertActionPerformed(evt);
            }
        });

        btnDelete.setFont(new java.awt.Font("Times New Roman", 1, 12)); // NOI18N
        btnDelete.setText("Delete");
        btnDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDeleteActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelMidLayout = new javax.swing.GroupLayout(jPanelMid);
        jPanelMid.setLayout(jPanelMidLayout);
        jPanelMidLayout.setHorizontalGroup(
                jPanelMidLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanelMidLayout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addGroup(jPanelMidLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(lbAddressOnline)
                                .addGroup(jPanelMidLayout.createSequentialGroup()
                                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(btnUpdate, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 30, Short.MAX_VALUE)
                        .addGroup(jPanelMidLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(lbFileName)
                                .addGroup(jPanelMidLayout.createSequentialGroup()
                                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(jPanelMidLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                                .addComponent(btnDelete, javax.swing.GroupLayout.DEFAULT_SIZE, 72, Short.MAX_VALUE)
                                                .addComponent(btnInsert, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                        .addContainerGap())
        );
        jPanelMidLayout.setVerticalGroup(
                jPanelMidLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanelMidLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanelMidLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lbAddressOnline)
                                .addComponent(lbFileName))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelMidLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(btnUpdate)
                                .addGroup(jPanelMidLayout.createSequentialGroup()
                                        .addComponent(btnInsert)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(btnDelete))
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 97, Short.MAX_VALUE)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addContainerGap(24, Short.MAX_VALUE))
        );

        lbFileHeThong.setFont(new java.awt.Font("Times New Roman", 3, 14)); // NOI18N
        lbFileHeThong.setForeground(new java.awt.Color(0, 102, 102));
        lbFileHeThong.setText("Danh Sách File Trên Hệ Thống");

        jListFileShareTrenHeThong.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        jScrollPane3.setViewportView(jListFileShareTrenHeThong);

        lbFileDaTai.setFont(new java.awt.Font("Times New Roman", 3, 14)); // NOI18N
        lbFileDaTai.setForeground(new java.awt.Color(0, 102, 102));
        lbFileDaTai.setText("Danh Sách File Đã Tải Về");

        jListFileDaTai.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        jScrollPane4.setViewportView(jListFileDaTai);

        btnDownload.setFont(new java.awt.Font("Times New Roman", 1, 12)); // NOI18N
        btnDownload.setText("Download");
        btnDownload.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownloadActionPerformed(evt);
            }
        });

        btnPlay.setFont(new java.awt.Font("Times New Roman", 1, 12)); // NOI18N
        btnPlay.setText("Play");
        btnPlay.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPlayActionPerformed(evt);
            }
        });

        tfSearch.setFont(new java.awt.Font("Times New Roman", 0, 12)); // NOI18N
        tfSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                tfSearchActionPerformed(evt);
            }
        });

        btnSearch.setFont(new java.awt.Font("Times New Roman", 1, 12)); // NOI18N
        btnSearch.setText("Search");
        btnSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSearchActionPerformed(evt);
            }
        });

        btnStop.setFont(new java.awt.Font("Times New Roman", 1, 12)); // NOI18N
        btnStop.setText("Stop");
        btnStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStopActionPerformed(evt);
            }
        });

        lbNameSearch.setFont(new java.awt.Font("Times New Roman", 3, 14)); // NOI18N
        lbNameSearch.setForeground(new java.awt.Color(0, 102, 102));
        lbNameSearch.setText("Tìm Kiếm Nhạc");

        javax.swing.GroupLayout jPanelBottomLayout = new javax.swing.GroupLayout(jPanelBottom);
        jPanelBottom.setLayout(jPanelBottomLayout);
        jPanelBottomLayout.setHorizontalGroup(
                jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelBottomLayout.createSequentialGroup()
                        .addGap(28, 28, 28)
                        .addGroup(jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(lbFileHeThong, javax.swing.GroupLayout.PREFERRED_SIZE, 201, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(jPanelBottomLayout.createSequentialGroup()
                                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(btnDownload))
                                .addGroup(jPanelBottomLayout.createSequentialGroup()
                                        .addComponent(tfSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(btnSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addComponent(lbNameSearch))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(jPanelBottomLayout.createSequentialGroup()
                                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 222, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                                .addComponent(btnPlay, javax.swing.GroupLayout.DEFAULT_SIZE, 72, Short.MAX_VALUE)
                                                .addComponent(btnStop, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                                .addComponent(lbFileDaTai)))
        );
        jPanelBottomLayout.setVerticalGroup(
                jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanelBottomLayout.createSequentialGroup()
                        .addGroup(jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(lbFileHeThong)
                                .addComponent(lbFileDaTai))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(btnDownload)
                                .addGroup(jPanelBottomLayout.createSequentialGroup()
                                        .addComponent(btnPlay)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(btnStop))
                                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 122, Short.MAX_VALUE)
                                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addGap(18, 18, 18)
                        .addComponent(lbNameSearch)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelBottomLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(btnSearch)
                                .addComponent(tfSearch, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(66, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPaneMainLayout = new javax.swing.GroupLayout(jPaneMain);
        jPaneMain.setLayout(jPaneMainLayout);
        jPaneMainLayout.setHorizontalGroup(
                jPaneMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPaneMainLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPaneMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(jPanelMid, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGroup(jPaneMainLayout.createSequentialGroup()
                                        .addGroup(jPaneMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addComponent(jPanelTop, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                                .addComponent(jPanelBottom, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                        .addContainerGap())))
        );
        jPaneMainLayout.setVerticalGroup(
                jPaneMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPaneMainLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanelTop, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelMid, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelBottom, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addComponent(jPaneMain, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jPaneMain, javax.swing.GroupLayout.PREFERRED_SIZE, 479, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>                        

    private void btnUpdateActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        if (socketRecieve.isConnected()) {
            socketRecieve.close();
        }
        updateAddress();
        xulySauKhiUpDateAddress();
    }

    private void btnInsertActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        operationInsert("Open afile", 1);
    }

    private void btnDeleteActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        operationDeleted();
    }

    private void btnPlayActionPerformed(java.awt.event.ActionEvent evt) {
        try {
            // TODO add your handling code here:
            operationPlay();
        } catch (InterruptedException ex) {
            System.out.println(ex.toString());
        }
    }

    private void tfSearchActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
    }

    private void btnSearchActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        operationSearch();
    }

    private void btnStopActionPerformed(java.awt.event.ActionEvent evt) {
        try {
            // TODO add your handling code here:
            operationStop();
        } catch (InterruptedException ex) {
            System.err.println(ex.toString());
        }
    }

    private void btnDownloadActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
        operationDownload();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Udp_Client2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Udp_Client2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Udp_Client2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Udp_Client2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                try {
                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                } catch (ClassNotFoundException ex) {
                    Logger.getLogger(Udp_Client2.class.getName()).log(Level.SEVERE, null, ex);
                } catch (InstantiationException ex) {
                    Logger.getLogger(Udp_Client2.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IllegalAccessException ex) {
                    Logger.getLogger(Udp_Client2.class.getName()).log(Level.SEVERE, null, ex);
                } catch (UnsupportedLookAndFeelException ex) {
                    Logger.getLogger(Udp_Client2.class.getName()).log(Level.SEVERE, null, ex);
                }

                Udp_Client2 udp = new Udp_Client2();
                udp.setVisible(true);
                udp.setTitle("Peer To Peer");
                //load_listAddress
                udp.loadAddress(filePathNodeName);
                //load_listFileChiaSe
                udp.loadFileInsert(udp.getFolderPathShare(), udp.jListFileName);
                //load_listFileDownload
                udp.loadFileDownload(udp.getFolderPathDownload(), udp.jListFileDaTai);
                //load_listFileChiaSeTrenHeThong
                udp.loadFileShareHeThongLanDau(udp.getfilePathShareHeThong());
            }
        });
        //Trong ham main

        try {

            socket = new DatagramSocket(PORT);

            byte[] receiveData = new byte[1024];
            byte[] sendData = new byte[1024];
            while (true) {

                receiveData = new byte[1024];

                DatagramPacket receivePacket
                        = new DatagramPacket(receiveData, receiveData.length);

                System.out.println("Waiting for datagram packet");

                socket.receive(receivePacket);

                String sentence = new String(receivePacket.getData());

                IPAddress = receivePacket.getAddress();
                int port = receivePacket.getPort();
                String s1 = sentence.substring(8);
                //xu ly xem la lenh gi tu node gui
                //String[] s = sentence.split(" ");
                int type = 0;

                if (sentence.contains("update address")) {
                    type = 1;
                } else if (sentence.contains("download")) {

                    s1 = s1.trim();
                    System.out.println(s1);
                    type = 2;
                } else if (sentence.contains("update sharefile")) {
                    type = 3;
                } else if (sentence.contains("insert sharefile")) {
                    type = 4;
                } else if (sentence.contains("delete sharefile")) {
                    type = 5;
                }

                if (type == 1) {
                    //sau khi nhan lenh se gui file lai cho node yeu cau
                    //xu ly file can gui

                    String fileLink = filePathNodeName;
                    File file = new File(fileLink);
                    FileInputStream f = new FileInputStream(file);

                    //chuyen thanh byte
                    byte[] b = new byte[1024];
                    int remainLength = (int) file.length();
                    int off = 0;
                    while (remainLength >= 1024) {
                        b = new byte[1024];

                        f.read(b, 0, 1024);

                        off = off + 1024;
                        remainLength = remainLength - 1024;
                        //

                        DatagramPacket dp = new DatagramPacket(b, b.length, InetAddress.getLocalHost(), port);
                        System.out.println("Sending data to " + b.length
                                + " bytes to server, port " + port);

                        socket.send(dp);

                    }
                    if (remainLength > 0) {

                        b = new byte[remainLength];
                        int read = f.read(b, 0, remainLength);
                        System.out.println("The number of bytes will be read: " + read);

                        DatagramPacket dp = new DatagramPacket(b, b.length, InetAddress.getLocalHost(), port);
                        System.out.println("Sending data to " + b.length
                                + " bytes to server.");

                        socket.send(dp);
                    }
                    f.close();

                } else if (type == 2) {
                    //sau khi nhan lenh se gui file lai cho node yeu cau
                    //xu ly file can gui
                    //s = "download abc.mp3"
                    String fileLink = folderPathShare + s1;
                    File file = new File(fileLink);
                    FileInputStream f = new FileInputStream(file);

                    //chuyen thanh byte
                    byte[] b = new byte[1024];
                    int remainLength = (int) file.length();
                    int off = 0;
                    while (remainLength >= 1024) {
                        b = new byte[1024];

                        f.read(b, 0, 1024);

                        off = off + 1024;
                        remainLength = remainLength - 1024;
                        //

                        DatagramPacket dp = new DatagramPacket(b, b.length, InetAddress.getLocalHost(), port);
                        System.out.println("Sending data to " + b.length
                                + " bytes to server, port " + port);

                        socket.send(dp);

                    }
                    if (remainLength > 0) {

                        b = new byte[remainLength];
                        int read = f.read(b, 0, remainLength);
                        System.out.println("The number of bytes will be read: " + read);

                        DatagramPacket dp = new DatagramPacket(b, b.length, InetAddress.getLocalHost(), port);
                        System.out.println("Sending data to " + b.length
                                + " bytes to server.");

                        socket.send(dp);
                    }
                    f.close();
                } else if (type == 3) {
                    //sau khi nhan lenh se gui file lai cho node yeu cau
                    //xu ly file can gui

                    //tao file luu listshare     
                    File file = new File("updatesharefile.txt");
                    if (file.exists()) {
                        file.createNewFile();
                    }

                    FileWriter fw = new FileWriter(file);
                    BufferedWriter bw = new BufferedWriter(fw);
                    File folder = new File(folderPathShare);
                    File[] listOfFiles = folder.listFiles();
                    //ArrayList<String> results = new ArrayList<String>();
                    //DefaultListModel model = new DefaultListModel();
                    for (int i = 0; i < listOfFiles.length; i++) {
                        if (listOfFiles[i].isFile()) {

                            bw.write(nodeName + " " + listOfFiles[i].getName() + "\r\n");

                        } else if (listOfFiles[i].isDirectory()) {

                        }
                    }
                    bw.close();
                    fw.close();

                    FileInputStream f = new FileInputStream(file);

                    //chuyen thanh byte
                    byte[] b = new byte[1024];
                    int remainLength = (int) file.length();
                    int off = 0;
                    while (remainLength >= 1024) {
                        b = new byte[1024];

                        f.read(b, 0, 1024);

                        off = off + 1024;
                        remainLength = remainLength - 1024;
                        //

                        DatagramPacket dp = new DatagramPacket(b, b.length, InetAddress.getLocalHost(), port);
                        System.out.println("Sending data to " + b.length
                                + " bytes to server, port " + port);

                        socket.send(dp);

                    }
                    if (remainLength > 0) {

                        b = new byte[remainLength];
                        int read = f.read(b, 0, remainLength);
                        System.out.println("The number of bytes will be read: " + read);

                        DatagramPacket dp = new DatagramPacket(b, b.length, InetAddress.getLocalHost(), port);
                        System.out.println("Sending data to " + b.length
                                + " bytes to server.");

                        socket.send(dp);
                    }
                    f.close();
                }
            }
        } catch (SocketException ex) {
            System.out.println(ex.toString());
        } catch (IOException ex) {
            System.out.println(ex.toString());
        }

    }
    //het ham main
    // Variables declaration - do not modify                     
    private javax.swing.JButton btnDelete;
    private javax.swing.JButton btnDownload;
    private javax.swing.JButton btnInsert;
    private javax.swing.JButton btnPlay;
    private javax.swing.JButton btnSearch;
    private javax.swing.JButton btnStop;
    private javax.swing.JButton btnUpdate;
    private javax.swing.JList<String> jListAddress;
    private javax.swing.JList<String> jListFileDaTai;
    private javax.swing.JList<String> jListFileName;
    private javax.swing.JList<String> jListFileShareTrenHeThong;
    private javax.swing.JPanel jPaneMain;
    private javax.swing.JPanel jPanelBottom;
    private javax.swing.JPanel jPanelMid;
    private javax.swing.JPanel jPanelTop;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JLabel lbAddressOnline;
    private javax.swing.JLabel lbFileDaTai;
    private javax.swing.JLabel lbFileHeThong;
    private javax.swing.JLabel lbFileName;
    private javax.swing.JLabel lbNameSearch;
    private javax.swing.JLabel lbTitle;
    private javax.swing.JTextField tfSearch;
    // End of variables declaration                   

    private void updateAddress() {

        this.setLenh("update address");
        this.setSelectedName(jListAddress.getSelectedValue());
        keepGoing = false;
        try {
            ArrayList<String> arr = new ArrayList<String>();
            IPAddress = InetAddress.getByName("127.0.0.1");
            socketRecieve = null;
            //lay string lenh cua udp click button
            String s = this.getLenh();

            String selected = "";
            //lay dong lenh ma jlist udp chon
            selected = this.getSelectedName();
            //tach chuoi lay port cna gui lenh
            String[] selection = selected.split(" ");
            Integer port = Integer.parseInt(selection[1]);

            System.out.println("Attemping to connect to " + IPAddress
                    + ") via UDP port " + port);
            //tao soc ket tho port cua minh

            socketRecieve = new DatagramSocket(this.getReceivePort());

            //gui lenh update address va nhan ve file node.txt
            byte[] sendData = new byte[1024];
            sendData = s.getBytes();

            DatagramPacket sendPacket
                    = new DatagramPacket(sendData, sendData.length, IPAddress, port);
            socketRecieve.send(sendPacket);

            //nhan file
            byte[] receiveData = new byte[1024];
            int off = 0;

            //co the so sanh la lenh gi de tao file thich hop
            String tam = "";
            // tao file
            FileOutputStream fos = new FileOutputStream(new File(this.getFolderPathRoot() + "checknode.txt"));
            //FileOutputStream fos = new FileOutputStream(new File("c:/checknode.txt"));
            while (true) {
                socketRecieve.setSoTimeout(1500);
                try {
                    receiveData = new byte[1024];

                    DatagramPacket dp = new DatagramPacket(receiveData, receiveData.length);

                    socketRecieve.receive(dp);

                    keepGoing = true;

                    byte[] b1 = new byte[dp.getLength()];
                    fos.write(receiveData, 0, b1.length);
                    off = off + b1.length;

                    //InetAddress address = dp.getAddress();
                    //int portSend = dp.getPort();
                } catch (SocketTimeoutException ste) {
                    //xu ly xem keepGoin co = true
                    if (keepGoing == true) {
                        //co nhan file tra ve thi xu ly them vao file node.txt cua minh
                        //doc file node cua minh len ghi vao List

                        File file = new File(filePathNodeName);
                        FileReader fr = new FileReader(file);
                        BufferedReader br = new BufferedReader(fr);
                        String line = "";
                        while ((line = br.readLine()) != null) {
                            arr.add(line);
                        }
                        br.close();
                        fr.close();

                        //doc tiep file node.txt vua nhan ve
                        file = new File(this.getFolderPathRoot() + "checknode.txt");
                        fr = new FileReader(file);
                        br = new BufferedReader(fr);
                        while ((line = br.readLine()) != null) {
                            if (kiemtra(arr, line) == 0) {
                                if (!(line.contains(this.getNodeName()))) {
                                    arr.add(line);
                                }
                            }
                        }
                        br.close();
                        fr.close();
                        //ghi lai ket qua vao file node.txt cua minh
                        file = new File(this.getFolderPathRoot() + "node.txt");
                        FileWriter fw = new FileWriter(file);
                        BufferedWriter bw = new BufferedWriter(fw);
                        for (int i = 0; i < arr.size(); i++) {
                            bw.write(arr.get(i) + "\r\n");
                        }
                        bw.close();
                        fw.close();
                        loadAddress(filePathNodeName);
                    } else {
                        //khong nhan file tra ve
                        this.operationDeletedNode(this.folderPathRoot, selected);
                    }
                    socketRecieve.close();
                    break;
                }
            }
            fos.close();
            keepGoing = false;
            //neu button update thi lenh la update address
            if (s.equals("update address")) {
                if (!(arr.isEmpty())) {
                    for (int i = 0; i < arr.size(); i++) {
                        //xu ly tung node get duoc tu file
                        //tach port cua node get duoc
                        keepGoing = false;
                        selected = arr.get(i);
                        String[] adr = arr.get(i).split(" ");
                        Integer p = Integer.parseInt(adr[1]);
                        socketRecieve = new DatagramSocket(this.getReceivePort());
                        sendData = new byte[1024];
                        sendData = s.getBytes();

                        //gui goi ping den port
                        sendPacket
                                = new DatagramPacket(sendData, sendData.length, IPAddress, p);
                        socketRecieve.send(sendPacket);

                        //nhan file
                        receiveData = new byte[1024];
                        off = 0;

                        //co the so sanh la lenh gi de tao file thich hop
                        tam = "";
                        // tao file ten bat ky luu du lieu nhan ve
                        fos = new FileOutputStream(new File("ping.txt"));

                        while (true) {
                            socketRecieve.setSoTimeout(1000);
                            try {
                                receiveData = new byte[1024];

                                DatagramPacket dp = new DatagramPacket(receiveData, receiveData.length);

                                socketRecieve.receive(dp);

                                keepGoing = true;

                                byte[] b1 = new byte[dp.getLength()];
                                fos.write(receiveData, 0, b1.length);
                                off = off + b1.length;

                                InetAddress address = dp.getAddress();
                                int portSend = dp.getPort();

                            } catch (SocketTimeoutException ste) {
                                //xu ly xem keepGoin co = true
                                if (keepGoing == true) {
                                    //co nhan file tra ve
                                } else {
                                    //khong nhan file tra ve
                                    this.operationDeletedNode(this.folderPathRoot, selected);
                                }
                                socketRecieve.close();
                                break;
                            }
                        }
                        fos.close();
                        keepGoing = false;
                    }
                }

            }
        } catch (IOException ex) {
            System.out.println(ex.toString());
        }
    }

    public void loadAddress(String file) {
        try {
            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);
            DefaultListModel model = new DefaultListModel();
            //String title = "NODE Port";
            //model.addElement(title);
            String line = "";
            while ((line = br.readLine()) != null) {
                model.addElement(line);
            }
            jListAddress.setModel(model);
            fr.close();
            br.close();
        } catch (Exception e) {
            System.out.println(e.toString());
        }
    }

    public void loadFileInsert(String folderPath, JList jListName) {
        try {
            ArrayList<String> results = new ArrayList<String>();
            DefaultListModel model = new DefaultListModel();

            File file = new File(this.getfilePathShareHeThong());

            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);

            String line = "";
            while ((line = br.readLine()) != null) {
                results.add(line);
            }

            File folder = new File(folderPath);
            File[] listOfFiles = folder.listFiles();

            for (int i = 0; i < listOfFiles.length; i++) {
                if (listOfFiles[i].isFile()) {
                    //System.out.println("File " + listOfFiles[i].getName());
                    //kiem tra xem co trung lap khong

                    String tam = listOfFiles[i].getName();
                    if ((kiemtra(results, tam)) == 0) {
                        results.add(listOfFiles[i].getName());
                    }
                    model.addElement(listOfFiles[i].getName());
                } else if (listOfFiles[i].isDirectory()) {
                    //System.out.println("Directory " + listOfFiles[i].getName());
                }
            }
            jListName.setModel(model);
            //ghi ket qua lai file note1_listfileshare           

            FileWriter fw = new FileWriter(file);
            BufferedWriter bw = new BufferedWriter(fw);

            for (int i = 0; i < results.size(); i++) {
                String s = results.get(i) + "\r\n";
                bw.write(s);
            }
            bw.close();
            fw.close();
        } catch (Exception e) {
            System.out.print(e.toString());
        }
    }

    public void loadFileDelete(String filePath, JList jListName) {
        try {
            ArrayList<String> results = new ArrayList<String>();
            ArrayList<String> folderShare = new ArrayList<String>();
            DefaultListModel model = new DefaultListModel();

            File file = new File(this.getfilePathShareHeThong());

            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);

            String line = "";
            while ((line = br.readLine()) != null) {
                results.add(line);
            }

            File folder = new File(folderPathShare);
            File[] listOfFiles = folder.listFiles();

            for (int i = 0; i < listOfFiles.length; i++) {
                if (listOfFiles[i].isFile()) {
                    String tam = listOfFiles[i].getName();
                    if ((kiemtra(folderShare, tam)) == 0) {
                        folderShare.add(listOfFiles[i].getName());
                    }
                    model.addElement(listOfFiles[i].getName());
                } else if (listOfFiles[i].isDirectory()) {
                    //System.out.println("Directory " + listOfFiles[i].getName());
                }
            }
            jListName.setModel(model);
            //ghi ket qua lai file note1_listfileshare           

            FileWriter fw = new FileWriter(file);
            BufferedWriter bw = new BufferedWriter(fw);

            delete(results, folderShare);

            for (int i = 0; i < results.size(); i++) {
                String s = results.get(i) + "\r\n";
                bw.write(s);
            }
            bw.close();
            fw.close();
        } catch (Exception e) {
            System.out.print(e.toString());
        }
    }

    public void loadFileShareHeThongLanDau(String filePath) {
        this.setLenh("update sharefile");
        operationUpdateFileShare();
        socketRecieve.close();

        //ArrayList<String> results = new ArrayList<String>();
        DefaultListModel model = new DefaultListModel();
        File file = new File(filePath);

        try {
            if (!(file.exists())) {
                file.createNewFile();
            }

            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);
            ArrayList<String> arr = new ArrayList<String>();
            String line = "";
            while ((line = br.readLine()) != null) {
                if (kiemtra(jListFileName, line) == 1) {
                    //model.addElement(line);
                    arr.add(this.getNodeName() + "_" + line);
                } else {
                    //model.addElement(line);
                    arr.add(line);
                }
            }
            br.close();
            fr.close();

            FileWriter fw = new FileWriter(file);
            BufferedWriter bw = new BufferedWriter(fw);
            for (int i = 0; i < arr.size(); i++) {
                bw.write(arr.get(i) + "\r\n");
            }
            bw.close();
            fw.close();

            //xoa ten file trung
            deleteFileName();

            file = new File(filePath);
            fr = new FileReader(file);
            br = new BufferedReader(fr);
            line = "";
            while ((line = br.readLine()) != null) {
                model.addElement(line);
            }
            br.close();
            fr.close();
        } catch (IOException ex) {
            System.out.println(ex.toString());
        }
        jListFileShareTrenHeThong.setModel(model);

    }

    public void loadFileShareHeThong(String filePath) {
        this.setLenh("update sharefile");
        //operationUpdateFileShare();
        //socketRecieve.close();

        //ArrayList<String> results = new ArrayList<String>();
        DefaultListModel model = new DefaultListModel();
        File file = new File(filePath);

        try {
            if (!(file.exists())) {
                file.createNewFile();
            }

            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);
            ArrayList<String> arr = new ArrayList<String>();
            String line = "";
            while ((line = br.readLine()) != null) {
                if (kiemtra(jListFileName, line) == 1) {
                    //model.addElement(line);
                    arr.add(this.getNodeName() + "_" + line);
                } else {
                    //model.addElement(line);
                    arr.add(line);
                }
            }
            br.close();
            fr.close();

            FileWriter fw = new FileWriter(file);
            BufferedWriter bw = new BufferedWriter(fw);
            for (int i = 0; i < arr.size(); i++) {
                bw.write(arr.get(i) + "\r\n");
            }
            bw.close();
            fw.close();

            //xoa ten file trung
            deleteFileName();

            file = new File(filePath);
            fr = new FileReader(file);
            br = new BufferedReader(fr);
            line = "";
            while ((line = br.readLine()) != null) {
                model.addElement(line);
            }
            br.close();
            fr.close();
        } catch (IOException ex) {
            System.out.println(ex.toString());
        }
        jListFileShareTrenHeThong.setModel(model);
    }

    public void loadFileDownload(String folderPath, JList jListName) {
        File folder = new File(folderPath);
        File[] listOfFiles = folder.listFiles();
        //ArrayList<String> results = new ArrayList<String>();
        DefaultListModel model = new DefaultListModel();
        for (int i = 0; i < listOfFiles.length; i++) {
            if (listOfFiles[i].isFile()) {
                //System.out.println("File " + listOfFiles[i].getName());
                //results.add(listOfFiles[i].getName());
                model.addElement(listOfFiles[i].getName());
            } else if (listOfFiles[i].isDirectory()) {
                //System.out.println("Directory " + listOfFiles[i].getName());
            }
        }
        jListName.setModel(model);
    }

    public void operationInsert(String title, int type) {
        JFileChooser chooser = new JFileChooser();
        chooser.setDialogTitle(title);
        int choose = 0;
        switch (type) {
            case INSERT:
                choose = chooser.showOpenDialog(null);
                break;
        }
        if (choose == JFileChooser.APPROVE_OPTION) {
            File file = chooser.getSelectedFile();
            switch (type) {
                case INSERT:
                    insertFile(file, folderPathShare);
                    break;
            }
        }
    }

    private void insertFile(File file, String folderPath) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        InputStream is = null;
        OutputStream os = null;
        try {
            //File aFile = new File("AFile.txt");
            String fileName = file.getName();
            String filePath = folderPath + fileName;
            //System.out.println(filePath);

            File bFile = new File(filePath);

            is = new FileInputStream(file);
            os = new FileOutputStream(bFile);

            byte[] buffer = new byte[1024];
            int length;
            // copy the file content in bytes
            while ((length = is.read(buffer)) > 0) {
                os.write(buffer, 0, length);
            }

            is.close();
            os.close();
            loadFileInsert(folderPath, jListFileName);
            loadFileShareHeThong(this.getfilePathShareHeThong());
            //System.out.println("Fileopied successfull!");

        } catch (Exception e) {
            System.out.println(e.toString());
        }
    }

    public void operationDeleted() {
        String fileName = jListFileName.getSelectedValue();
        this.setSelectedName(fileName);
        File file = new File(folderPathShare + fileName);
        file.delete();
        loadFileDelete(folderPathShare, jListFileName);
        loadFileShareHeThong(this.getfilePathShareHeThong());
    }

    public void operationDeletedNode(String folderRootPath, String s) {
        File file = new File(filePathNodeName);

        try {
            //lay du lieu file node.txt cua node
            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);
            ArrayList<String> arr = new ArrayList<String>();
            String line = "";
            while ((line = br.readLine()) != null) {
                arr.add(line);
            }
            //so snah neu giong chuoi can xoa
            for (int i = 0; i < arr.size(); i++) {
                if (arr.get(i).equals(s)) {
                    arr.remove(i);
                }
            }
            br.close();
            fr.close();
            //ghi lai file node.txt
            file = new File(folderRootPath + "node.txt");
            FileWriter fw = new FileWriter(file);
            BufferedWriter bw = new BufferedWriter(fw);

            for (int i = 0; i < arr.size(); i++) {
                bw.write(arr.get(i) + "\r\n");
            }
            bw.close();
            fw.close();
            loadAddress(folderRootPath + "node.txt");
        } catch (FileNotFoundException ex) {
            System.out.println(ex.toString());
        } catch (IOException ex) {
            System.out.println(ex.toString());
        }

    }

    public void operationPlay() throws InterruptedException {
        this.setSelectedName(jListFileDaTai.getSelectedValue());

        Thread.sleep(1000);
        play = new PlayMp3Thread(this);
        play.start();
    }

    public void operationStop() throws InterruptedException {
        play.stop();
    }

    public void operationSearch() {
        String fileName = tfSearch.getText();

    }

    public int kiemtra(ArrayList<String> arr, String s) {
        for (int i = 0; i < arr.size(); i++) {
            if (arr.get(i).contains(s)) {
                return 1;
            }
        }
        return 0;
    }

    public int kiemtra(JList<String> list, String s) {
        ListModel model = list.getModel();
        for (int i = 0; i < model.getSize(); i++) {
            if (model.getElementAt(i).equals(s)) {
                //file co trong thu muc share
                return 1;
            }
        }
        return 0;
    }

    public void delete(ArrayList<String> arr, ArrayList<String> share) {
        for (int i = 0; i < arr.size(); i++) {
            String[] s = arr.get(i).split("_");
            if (s[0].equals(this.getNodeName())) {
                if (kiemtra(share, s[1]) == 0) {
                    arr.remove(i);
                }
            }
        }
    }

    public void deleteFileName() {
        File file = new File(filePathShareHeThong);
        try {
            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);
            ArrayList<String> list = new ArrayList<String>();

            String line = "";
            while ((line = br.readLine()) != null) {
                list.add(line);
            }
            br.close();
            fr.close();

            for (int i = 0; i < list.size(); i++) {
                for (int j = 0; j < list.size(); j++) {
                    if (i != j) {
                        if (list.get(i).equals(list.get(j))) {
                            list.remove(j);
                        }
                    }
                }
            }
            FileWriter fw = new FileWriter(file);
            BufferedWriter bw = new BufferedWriter(fw);
            for (int i = 0; i < list.size(); i++) {
                bw.write(list.get(i) + "\r\n");
            }
            bw.close();
            fw.close();

        } catch (FileNotFoundException ex) {
            System.out.println(ex.toString());
        } catch (IOException ex) {
            System.out.println(ex.toString());
        }

    }

    public void operationUpdateFileShare() {
        try {
            keepGoing = false;
            ArrayList<String> arr = new ArrayList<String>();
            IPAddress = InetAddress.getByName("127.0.0.1");
            //lay string lenh cua udp click button
            String lenh = this.getLenh();

            String selected = "";
            //lay dong lenh ma jlist udp chon
            //selected = this.getSelectedName();
            //tach chuoi lay port cna gui lenh
            //String[] selection = selected.split(" ");
            //Integer port = Integer.parseInt(selection[1]);

            //.out.println("Attemping to connect to " + IPAddress + ") via UDP port " + port);
            //tao soc ket tho port cua minh
            //gui lenh update address va nhan ve file updatesharefile.txt
            byte[] sendData = new byte[1024];
            sendData = lenh.getBytes();
            //lay danh sach cac node dang ket noi
            ListModel<String> model = jListAddress.getModel();
            // chay vs tung node
            for (int i = 0; i < model.getSize(); i++) {
                //xu ly tung address gui lenh update sharefile
                socketRecieve = new DatagramSocket(this.getReceivePortDownload());
                keepGoing = false;
                String[] adr = model.getElementAt(i).split(" ");
                Integer port = Integer.parseInt(adr[1]);

                DatagramPacket sendPacket
                        = new DatagramPacket(sendData, sendData.length, IPAddress, port);
                socketRecieve.send(sendPacket);

                //nhan file
                byte[] receiveData = new byte[1024];
                int off = 0;

                //co the so sanh la lenh gi de tao file thich hop
                // tao file
                FileOutputStream fos = new FileOutputStream(new File(this.getFolderPathRoot() + "updatesharefile.txt"));
                //FileOutputStream fos = new FileOutputStream(new File("d:/share.txt"));
                while (true) {
                    socketRecieve.setSoTimeout(1000);
                    try {
                        receiveData = new byte[1024];

                        DatagramPacket dp = new DatagramPacket(receiveData, receiveData.length);

                        socketRecieve.receive(dp);

                        keepGoing = true;

                        byte[] b1 = new byte[dp.getLength()];
                        fos.write(receiveData, 0, b1.length);
                        off = off + b1.length;

                        InetAddress address = dp.getAddress();
                        int portSend = dp.getPort();

                    } catch (SocketTimeoutException ste) {
                        //xu ly xem keepGoin  = true
                        if (keepGoing == true) {
                            //co nhan file tra ve thi xu ly them vao file nodex_listsharefile.txt cua minh
                            //doc file node cua minh len ghi vao List
                            System.out.println("da nhan duoc file");
                            File file = new File(filePathShareHeThong);
                            FileReader fr = new FileReader(file);
                            BufferedReader br = new BufferedReader(fr);
                            String line = "";
                            while ((line = br.readLine()) != null) {
                                arr.add(line);
                            }
                            br.close();
                            fr.close();

                            //doc tiep file node.txt vua nhan ve
                            file = new File(this.getFolderPathRoot() + "updatesharefile.txt");
                            fr = new FileReader(file);
                            br = new BufferedReader(fr);
                            while ((line = br.readLine()) != null) {
                                if (kiemtra(arr, line) == 0) {
                                    arr.add(line);
                                }
                            }
                            br.close();
                            fr.close();
                            //ghi lai ket qua vao file node.txt cua minh
                            file = new File(filePathShareHeThong);
                            FileWriter fw = new FileWriter(file);
                            BufferedWriter bw = new BufferedWriter(fw);

                            for (int j = 0; j < arr.size(); j++) {
                                bw.write(arr.get(j) + "\r\n");
                            }
                            bw.close();
                            fw.close();
                            //loadAddress(filePathNodeName);
                        } else {
                            //khong nhan file tra ve thi cho qua
                            //this.operationDeletedNode(this.folderPathRoot, selected);
                        }
                        socketRecieve.close();
                        break;
                    }
                }
                fos.close();
            }
            keepGoing = false;

        } catch (IOException ex) {
            System.out.println(ex.toString());
        }
    }

    public void xulySauKhiUpDateAddress() {
        ArrayList<String> node = new ArrayList<String>();
        node.add("Node1 4001");
        node.add("Node2 4002");
        node.add("Node3 4003");
        node.add("Node4 4004");
        for (int i = 0; i < node.size(); i++) {
            boolean check = false;
            String[] s1 = node.get(i).split(" ");
            if (!(s1[0].equals(nodeName))) {
                //s1[1] la port
                int port = Integer.parseInt(s1[1]);
                ArrayList<String> arr = new ArrayList<String>();
                try {
                    IPAddress = InetAddress.getByName("127.0.0.1");

                    socketRecieve = null;
                    //lay string lenh cua udp click button
                    String s = "update address";

                    //String selected = "";
                    //lay dong lenh ma jlist udp chon
                    //selected = this.getSelectedName();
                    //tach chuoi lay port cna gui lenh
                    //String[] selection = selected.split(" ");
                    //Integer port = Integer.parseInt(selection[1]);
                    System.out.println("Attemping to connect to " + IPAddress
                            + ") via UDP port " + port);
                    //tao soc ket tho port cua minh

                    socketRecieve = new DatagramSocket(this.getReceivePort());

                    //gui lenh update address va nhan ve file node.txt
                    byte[] sendData = new byte[1024];
                    sendData = s.getBytes();

                    DatagramPacket sendPacket
                            = new DatagramPacket(sendData, sendData.length, IPAddress, port);
                    socketRecieve.send(sendPacket);

                    //nhan file
                    byte[] receiveData = new byte[1024];
                    int off = 0;

                    //co the so sanh la lenh gi de tao file thich hop
                    //String tam = "";
                    // tao file
                    FileOutputStream fos = new FileOutputStream(new File(this.getFolderPathRoot() + "checknode.txt"));
                    //FileOutputStream fos = new FileOutputStream(new File("c:/checknode.txt"));
                    while (true) {
                        socketRecieve.setSoTimeout(1500);
                        try {
                            receiveData = new byte[1024];

                            DatagramPacket dp = new DatagramPacket(receiveData, receiveData.length);

                            socketRecieve.receive(dp);

                            check = true;

                            byte[] b1 = new byte[dp.getLength()];
                            fos.write(receiveData, 0, b1.length);
                            off = off + b1.length;

                            //InetAddress address = dp.getAddress();
                            //int portSend = dp.getPort();
                        } catch (SocketTimeoutException ste) {
                            //xu ly xem keepGoin co = true
                            if (check == true) {
                                //co nhan file tra ve thi xu ly them vao file node.txt cua minh
                                //doc file node cua minh len ghi vao List

                                File file = new File(filePathNodeName);
                                FileReader fr = new FileReader(file);
                                BufferedReader br = new BufferedReader(fr);
                                String line = "";
                                while ((line = br.readLine()) != null) {
                                    arr.add(line);
                                }
                                br.close();
                                fr.close();

                                //doc tiep file node.txt vua nhan ve
                                file = new File(this.getFolderPathRoot() + "checknode.txt");
                                fr = new FileReader(file);
                                br = new BufferedReader(fr);
                                while ((line = br.readLine()) != null) {
                                    if (kiemtra(arr, line) == 0) {
                                        if (!(line.contains(this.getNodeName()))) {
                                            arr.add(line);
                                        }
                                    }
                                }
                                br.close();
                                fr.close();
                                //ghi lai ket qua vao file node.txt cua minh
                                file = new File(this.getFolderPathRoot() + "node.txt");
                                FileWriter fw = new FileWriter(file);
                                BufferedWriter bw = new BufferedWriter(fw);
                                for (int j = 0; j < arr.size(); j++) {
                                    bw.write(arr.get(j) + "\r\n");
                                }
                                bw.close();
                                fw.close();
                                loadAddress(filePathNodeName);
                            } else {
                                //khong nhan file tra ve
                                this.operationDeletedNode(this.folderPathRoot, node.get(i));
                            }
                            socketRecieve.close();
                            break;
                        }
                    }
                    fos.close();
                } catch (IOException ex) {
                    System.out.println(ex.toString());
                }
            }
        }
    }

    public void operationDownload() {
        this.setSelectedName(jListFileShareTrenHeThong.getSelectedValue());

        String s0 = this.getSelectedName().substring(0, 5);
        String s1 = this.getSelectedName().substring(6);

        //get port
        int port = 0;
        if (s0.equals("Node1")) {
            port = 4001;
        } else if (s0.equals("Node2")) {
            port = 4002;
        } else if (s0.equals("Node3")) {
            port = 4003;
        } else if (s0.equals("Node4")) {
            port = 4004;
        }

        this.setLenh(("download " + s1));

        if (port == PORT) {
            //file can tai hien dang tren may
            InputStream is = null;
            OutputStream os = null;
            try {
                //File aFile = new File("AFile.txt");
                File file = new File(folderPathShare + s1);

                //String fileName = file.getName();
                String filePath = folderPathDownload + s1;
                //System.out.println(filePath);

                File bFile = new File(filePath);

                is = new FileInputStream(file);
                os = new FileOutputStream(bFile);

                byte[] buffer = new byte[1024];
                int length;
                // copy the file content in bytes
                while ((length = is.read(buffer)) > 0) {
                    os.write(buffer, 0, length);
                }

                is.close();
                os.close();
                loadFileDownload(folderPathDownload, jListFileDaTai);
                //loadFileInsert(folderPath, jListFileName);
                //loadFileShareHeThong(this.getfilePathShareHeThong());
                //System.out.println("Fileopied successfull!");

            } catch (Exception e) {
                System.out.println(e.toString());
            }
        } else {
            //file nam o cac node khac
            keepGoing = false;
            try {
                ArrayList<String> arr = new ArrayList<String>();
                IPAddress = InetAddress.getByName("127.0.0.1");
                socketRecieve = null;

                System.out.println("Attemping to connect to " + IPAddress
                        + ") via UDP port " + port);

                //tao soc ket tho port cua minh
                socketRecieve = new DatagramSocket(this.getReceivePort());

                //gui lenh update address va nhan ve file node.txt
                String lenh = this.getLenh();
                byte[] sendData = new byte[1024];
                sendData = lenh.getBytes();

                DatagramPacket sendPacket
                        = new DatagramPacket(sendData, sendData.length, IPAddress, port);
                socketRecieve.send(sendPacket);

                //nhan file
                byte[] receiveData = new byte[1024];
                int off = 0;

                //co the so sanh la lenh gi de tao file thich hop
                // tao file
                FileOutputStream fos = new FileOutputStream(new File(folderPathDownload + s1));
                //FileOutputStream fos = new FileOutputStream(new File("c:/checknode.txt"));
                while (true) {
                    socketRecieve.setSoTimeout(1500);
                    try {
                        receiveData = new byte[1024];

                        DatagramPacket dp = new DatagramPacket(receiveData, receiveData.length);

                        socketRecieve.receive(dp);

                        keepGoing = true;

                        byte[] b1 = new byte[dp.getLength()];
                        fos.write(receiveData, 0, b1.length);
                        off = off + b1.length;

                        //InetAddress address = dp.getAddress();
                        //int portSend = dp.getPort();
                    } catch (SocketTimeoutException ste) {
                        //xu ly xem keepGoin co = true
                        if (keepGoing == true) {
                            //co nhan file tra ve thi xu ly them vao file muc download
                            //load lai list download                           
                            loadFileDownload(folderPathDownload, jListFileDaTai);
                        } else {
                            //khong nhan file tra ve
                            File f = new File(folderPathDownload + s1);
                            if (f.exists()) {
                                f.delete();
                            }
                        }
                        socketRecieve.close();
                        break;
                    }
                }
                fos.close();
                keepGoing = false;
            } catch (Exception e) {
                System.out.println(e.toString());
            }

        }
    }

    public static String trimspace(String str) {
        str = str.replaceAll("\\s+", " ");
        str = str.replaceAll("(^\\s+|\\s+$)", "");
        return str;
    }
}
